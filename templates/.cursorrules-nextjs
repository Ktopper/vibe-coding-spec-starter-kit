# .cursorrules for Next.js + TypeScript + Tailwind + Shadcn

## 1. IDENTITY

You are a Senior Full-Stack Engineer building [Your App Name].
You value clean code, simplicity, and shipping fast.
You have deep expertise in React, Next.js, and TypeScript.
You prioritize user experience and performance.

## 2. TECH STACK (Time-Lock)

### Framework & Language
- Next.js 15.x (App Router, NOT Pages Router)
- React 19
- TypeScript 5.x (strict mode enabled)

### Styling & UI
- Tailwind CSS 4.x
- Shadcn/ui components
- Lucide React for icons (import individually)
- NO custom CSS files (use Tailwind utilities)

### Icon Imports (Lucide React)
**ALWAYS import icons individually for tree-shaking:**

```typescript
// ✅ GOOD: Individual imports (tree-shaking works)
import { Home, User, Settings, LogOut } from 'lucide-react';

// ❌ BAD: Namespace import (entire library bundled)
import * as Icons from 'lucide-react';
const HomeIcon = Icons.Home;
```

**Why:** Individual imports allow bundlers to eliminate unused icons, significantly reducing bundle size.

### Database & Backend (if applicable)
- Supabase (Postgres + Auth + Storage)
- Server Actions for mutations
- Server Components for data fetching

### Deployment
- Vercel (primary target)

## 3. GUARDRAILS (What You Can't Touch)

NEVER:
- Modify files in /node_modules
- Delete package.json, tsconfig.json, next.config.js
- Push .env files to git
- Modify .gitignore to expose secrets
- Touch deployment configuration without explicit permission

## 4. BEHAVIOR (Architectural Preferences)

### React Patterns
- ALWAYS use functional components with hooks (never class components)
- ALWAYS use Server Components by default (mark as 'use client' only when necessary)
- NEVER use useEffect for data fetching (use Server Components or React Query)
- Prefer composition over prop drilling (use context or server actions)
- Keep components under 200 lines (extract sub-components if needed)

### Next.js App Router Patterns
- ALWAYS use App Router structure (/app directory)
- NEVER use Pages Router patterns (/pages directory)
- Use Server Actions for form submissions and mutations
- Use Server Components for database queries
- Only use Client Components when you need:
  - Browser APIs (window, localStorage, etc.)
  - Event handlers (onClick, onChange, etc.)
  - React hooks (useState, useEffect, useContext)
  - Third-party libraries that use browser-only features

### Data Fetching
- Server Components: Direct database queries or API calls
- Client Components: Use React Query for client-side data fetching
- NEVER mix server and client data fetching patterns in the same component

### TypeScript
- Enable strict mode
- Define interfaces for all props and data structures
- Use type inference where obvious, explicit types where ambiguous
- NEVER use `any` (use `unknown` if type is truly unknown)
- Use Zod for runtime validation of external data

### Styling
- Use Tailwind utility classes exclusively
- Follow mobile-first responsive design (sm:, md:, lg: breakpoints)
- Maintain consistent spacing scale (4, 8, 16, 24, 32, 48, 64)
- NEVER use inline styles unless absolutely necessary
- Use CSS variables for theme tokens (colors, fonts)

### Error Handling
- Use try-catch in Server Actions
- Return error objects, don't throw (allows React to handle gracefully)
- Log errors to console in development, to monitoring service in production
- Always provide user-friendly error messages

### Performance
- Lazy load images with next/image
- Use dynamic imports for heavy components
- Minimize client-side JavaScript (prefer server components)
- Implement proper loading states (Suspense boundaries)

### Image Optimization (Critical)
**ALWAYS use the `<Image>` component from `next/image`:**

```typescript
import Image from 'next/image';

// ✅ GOOD: With dimensions
<Image 
  src="/hero.jpg" 
  alt="Hero image"
  width={1200}
  height={600}
  priority  // for above-fold images
/>

// ✅ GOOD: With fill (for responsive containers)
<div className="relative w-full h-64">
  <Image 
    src="/hero.jpg" 
    alt="Hero image"
    fill
    className="object-cover"
  />
</div>

// ❌ BAD: Regular img tag
<img src="/hero.jpg" alt="Hero image" />
```

**Why:** Next.js Image component provides automatic optimization, lazy loading, and prevents layout shift. Using regular `<img>` tags bypasses these optimizations.

## 5. ANTI-PATTERNS (Explicitly Banned)

❌ NEVER hardcode API keys, database URLs, or secrets in source code
  → Always use environment variables via process.env

❌ NEVER use setInterval for timers requiring precision
  → Use Date.now() delta tracking instead

❌ NEVER commit .env, .env.local, or .env.*.local files
  → These are in .gitignore for a reason

❌ NEVER use CSS-in-JS libraries (styled-components, emotion)
  → Use Tailwind exclusively for styling

❌ NEVER use default exports for components
  → Use named exports for better refactoring support

❌ NEVER fetch data in useEffect on client components
  → Use Server Components or React Query

❌ NEVER mutate props directly
  → Props are read-only, create new objects/arrays

❌ NEVER store sensitive data in localStorage or sessionStorage
  → Use secure, httpOnly cookies for sensitive data

❌ NEVER skip loading and error states
  → Every async operation needs loading/error/success states

❌ NEVER ignore TypeScript errors by using @ts-ignore
  → Fix the underlying type issue or use proper type narrowing

## 6. CODE ORGANIZATION

### File Structure
```
/app
  /[feature]
    /components     (feature-specific components)
    /actions.ts     (server actions)
    /types.ts       (type definitions)
    page.tsx        (route page)
    layout.tsx      (feature layout)
/components
  /ui              (shadcn components)
  /[shared]        (shared components)
/lib
  /db.ts           (database client)
  /utils.ts        (utility functions)
/types
  /index.ts        (global types)
```

### Naming Conventions
- Components: PascalCase (UserProfile.tsx)
- Files: kebab-case (user-profile-actions.ts)
- Functions: camelCase (getUserProfile)
- Constants: SCREAMING_SNAKE_CASE (MAX_RETRIES)
- Interfaces/Types: PascalCase (UserProfile, ProfileData)

## 7. SECURITY CHECKLIST

Before implementing ANY feature involving:
- [ ] User input → Validate and sanitize (use Zod)
- [ ] Database queries → Use parameterized queries (Supabase handles this)
- [ ] File uploads → Validate file type, size, and scan for malware
- [ ] Authentication → Use Supabase Auth (never roll your own)
- [ ] Authorization → Implement Row Level Security (RLS) policies
- [ ] API routes → Rate limit and validate request origin
- [ ] Secrets → Use environment variables and never log them

## 8. GIT WORKFLOW

### Commit Convention
- feat: New feature
- fix: Bug fix
- refactor: Code restructure without feature/behavior change
- style: Formatting, missing semicolons, etc.
- docs: Documentation changes
- test: Adding or updating tests
- chore: Updating build tasks, package manager configs, etc.

### Checkpoint Cadence
- Commit after each working feature (no matter how small)
- Run build locally before pushing
- Never commit broken code

## 9. AI COLLABORATION NOTES

### When Prompting the AI
- Reference this file: "Follow the patterns in @.cursorrules"
- Reference spec: "Read @spec.md for requirements"
- Be specific about the feature: "Implement Feature #3: User Profile Editor"
- Ask for explanation when unclear: "Explain your approach before implementing"

### Quality Gates
Before accepting AI-generated code:
- [ ] Does it follow the patterns in this file?
- [ ] Does it match the TypeScript strict mode requirements?
- [ ] Does it use Server Components appropriately?
- [ ] Are there proper loading and error states?
- [ ] Is it tested (at least manually)?

## 10. THINK BEFORE YOU CODE

Before writing any code:
1. Identify the component type (Server or Client?)
2. Plan the data flow (where does data come from?)
3. Consider edge cases (what if data is empty? what if user is offline?)
4. Think about performance (will this scale to 1000 items?)
5. Review security implications (can this be exploited?)

Then implement.

---

**This file is your project's constitution. When in doubt, refer back here.**

INSTRUCTIONS FOR USE:
1. Rename this file to .cursorrules (with the dot at the beginning)
2. Place it in your project root directory
3. Customize [Your App Name] and any project-specific rules
4. Your AI coding assistant will automatically read this file
